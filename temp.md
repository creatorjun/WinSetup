# WinSetup 프로젝트 성능 최적화 제안서 (Performance Optimization Advice)

## 📌 개요
현재 WinSetup 프로젝트는 클린 아키텍처와 기본적인 멀티스레딩 최적화가 잘 반영되어 있습니다. 하지만 대용량 파일 스캔, 빈번한 문자열 연산, 그리고 다중 디스크 환경에서의 효율성을 극대화하기 위해 다음과 같은 추가 최적화를 제안합니다.

---

## 1. MFTScanner: 경로 빌드 알고리즘 최적화 (Adapter Layer)
**현황:** `BuildFilePathMap`에서 모든 레코드에 대해 `GetFullPath`를 호출하며 루트까지 재귀적으로 탐색합니다. 이는 파일 개수가 $N$, 평균 깊이가 $D$일 때 $O(N \times D)$의 복잡도를 가집니다.
**제안:** **상향식(Bottom-up) 캐싱(Memoization)**을 도입하여 $O(N)$으로 개선하십시오.
- **구현 방향:**
  - `std::unordered_map<uint64_t, std::wstring>` 형태의 임시 캐시를 사용합니다.
  - 부모 경로가 이미 캐싱되어 있다면 즉시 결합하고, 없다면 재귀적으로 부모를 찾아 캐싱하며 내려옵니다.
- **기대 효과:** 수십만 개의 파일이 있는 볼륨 스캔 시 경로 구성 시간을 70% 이상 단축할 수 있습니다.

## 2. 문자열 연산 및 메모리 할당 최적화 (Domain/Adapter Layer)
**현황:** `NormalizeFilePath`, `ToLower`, `EndsWith` 등에서 `std::wstring` 객체를 빈번하게 생성 및 반환하여 힙 할당 경합이 발생할 수 있습니다.
**제안:** **`std::wstring_view`**와 기존 **`PoolAllocator`**를 적극 활용하십시오.
- **구현 방향:**
  - 읽기 전용 문자열 비교나 부분 문자열 탐색 시 `std::wstring_view`(C++17)를 사용하여 복사를 방지합니다.
  - `MFTFileRecord`와 같이 단기에 대량으로 생성되는 객체는 `winsetup::domain::PoolAllocator`를 적용하여 메모리 파편화를 줄입니다.

## 3. 유즈케이스 수준의 병렬 처리 (Application Layer)
**현황:** 디스크 분석(`AnalyzeDisksUseCase`) 및 열거 작업이 단일 루프 내에서 순차적으로 실행될 가능성이 높습니다.
**제안:** **물리 디스크 단위의 병렬 분석**을 수행하십시오.
- **구현 방향:**
  - `IThreadPool`을 사용하여 각 디스크의 분석 태스크를 개별적으로 `Submit` 합니다.
  - `AwaitAll` 패턴을 사용하여 모든 디스크 분석이 완료될 때까지 비동기적으로 대기합니다.
- **기대 효과:** NVMe SSD가 여러 개 장착된 시스템에서 전체 분석 시간을 비약적으로 단축할 수 있습니다.

## 4. UI 이벤트 발생 Throttling (Presentation Layer)
**현황:** `WimlibAdapter`나 스캐너에서 진행률을 `EventBus`로 보낼 때, 파일 단위로 이벤트를 발행하면 UI 스레드 메시지 큐에 부하가 걸릴 수 있습니다.
**제안:** **시간 기반 Throttling (최소 16ms~32ms 간격)**을 도입하십시오.
- **구현 방향:**
  - 마지막 이벤트 발행 시간을 기록하고, 일정 시간(예: 32ms, 약 30FPS)이 지나지 않았다면 이벤트를 무시하거나 누적하여 한 번에 보냅니다.
- **기대 효과:** 고속 복사 작업 중에도 GUI가 프리징되지 않고 매끄러운 응답성을 유지하게 합니다.

---

## 🛠 우선순위 가이드
1. **P0 (즉시 반영):** MFTScanner 경로 빌드 최적화 (스캔 성능 직결)
2. **P1 (안정성):** UI 이벤트 Throttling (사용자 경험 직결)
3. **P2 (고도화):** 유즈케이스 병렬화 및 메모리 풀 적용